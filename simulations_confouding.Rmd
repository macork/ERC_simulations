---
title: "Confouding adjustment"
author: "Michael Cork"
date: "1/20/2022"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = F)
rm(list = ls())
library(tidyverse)
library(data.table)
library(MASS)
library(parallel)
library(xgboost)
library(SuperLearner)
library(weights)
library(CBPS)
library(caret)
library(WeightIt)
library(chngpt)
library(cobalt)
#library("devtools")
#install_github("fasrc/CausalGPS")
library("CausalGPS")

# Set directory (based on username on cluster or local computer)
if (Sys.getenv("USER") == "mcork") {
  repo_dir <- "/n/dominici_nsaph_l3/projects/ERC_simulation/Simulation_studies/"
} else if (Sys.getenv("USER") == "michaelacork") {
  repo_dir <- "~/Desktop/Francesca_research/Simulation_studies/"
}

```

# Data generating mechanism
We evaluate the performance of our methods for fitting ERC curves in a variety of data settings. In each setting, we generate six confounders $(C_1, C_2, ..., C_6)$, which include a combination of continuous and categorical variables.
$$ C_1, ..., C_4 \sim N(0, I_4), C_5 \sim V \: \{-2, 2 \}, C_6 \sim U \: (-3, 3) $$

Where $N(0, I_4)$ denotes a multivariate normal distribution, $V \: \{-2, 2 \}$ denotes a discrete uniform distribution, and $U(3, 3)$ denotes a continuous uniform distribution. We generate the exposure based on four specifications of the relationship between confounding and exposure based on work by Xiao. 

The exposure $E$ is generated using four different specifications that rely on the function $\gamma(\mathbf{C})=-0.8+$ $(0.1,0.1,-0.1,0.2,0.1,0.1)$ C. Specifically,

1. $E=9 \times \gamma(\mathbf{C})+N(0,3)$; (simple linear)
2. $E=15 \times \gamma(\mathbf{C})+T(2)$; (heavy-tailed linear)
3. $E=7 \times \gamma(\mathbf{C}) + C_{3}^{2} + N(0,3)$ (nonlinear)
4.  $E=7 \times \gamma(\mathbf{C}) + C_{3}^{2} +  C_{1}C_{6} + N(0,3)$; (interaction)

The exposure is then rescaled such that all values lie between 0 and 20, to mimic what is typically seen in air pollution data. Scenario 1 has a linear relationship between $E$ and $C$ and GPS values are not heavy tailed. In scenario 2, the relationship between $E$ and $C$ stays linear, but GPS values are heavy tailed and include extreme values. Scenario 3 include a non-linear relationship between $E$ and $C$ and scenario 4 adds an interaction term to the relationship between the confounder and the exposure.

$$
\begin{split} 
Y|E,C &\sim N(\mu(E, C), 10^2) \\
\mu(E, C) &= 20 + 0.1*E - (2, 2, 3, -1, 2, 2)*C 
\end{split}
$$

Before fitting the model we can compare how well the covariates predict the exposure. We can first look at this without any noise, and we would expect that in scenario 1 and 2 it would perfectly capture the exposure given it is a linear function of the covariates, whereas the association would get significantly worse in scenario 3 and 4. 

```{r, eval = T, echo = F}
source(paste0(repo_dir, "/simulation_functions.R"))
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

# Function to rescale values between 0-20
scale_exposure <- function(x){20 * (x-min(x))/(max(x)-min(x))}

r_squared <- 
  rbindlist(mclapply(1:100, mc.cores = 10, function(sim){
    sample_size = 1000
    cf <- mvrnorm(n = sample_size,
                      mu = rep(0, 4),
                      Sigma = diag(4))
    cf5 <- sample(c((-2):2), sample_size, replace = T)
    cf6 <- runif(sample_size, min = -3, max = 3)
    confounders = cbind(cf, cf5, cf6)
    colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
    rbindlist(lapply(c(1:4), function(gps_mod){
      if (gps_mod == 1) {
              exposure = scale_exposure(cov_function(confounders))
            } else if (gps_mod == 2) {
              exposure = scale_exposure(cov_function(confounders))
            } else if (gps_mod == 3) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^2)
            } else if (gps_mod == 4) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"]))
            }
    data = data.table(cbind(exposure, confounders))
    lm_model <- lm(exposure ~ cf1 + cf2 + cf3 + cf4 + cf5 + cf6, data = data)
    data.table(gps_mod = gps_mod, r_squared = summary(lm_model)$adj.r.squared)
    }))
  }))

r_squared %>%
  dplyr::group_by(gps_mod) %>%
  dplyr::summarize(mean = mean(r_squared),
                   lower = quantile(r_squared, 0.1),
                   upper = quantile(r_squared, 0.9)) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear",
                                    gps_mod == 2 ~ "heavy tail",
                                    gps_mod == 3 ~ "nonlinear",
                                    gps_mod == 4 ~ "interaction"),
                          levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>%
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, 
                      x = factor(gps_mod)), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Adjusted r squared", title = "Adjusted r-squared when removing noise") + 
  theme_bw() +
  coord_cartesian(ylim = c(0, 1))
  
```

Now we do the same thing but include the noise terms into the model, so that scenario 1 and 2 are no longer perfectly described by the linear relationship between the covariates and exposure: 

```{r, eval = T, echo = F}
r_squared <- 
  rbindlist(mclapply(1:100, mc.cores = 10, function(sim){
    sample_size = 1000
    cf <- mvrnorm(n = sample_size,
                      mu = rep(0, 4),
                      Sigma = diag(4))
    cf5 <- sample(c((-2):2), sample_size, replace = T)
    cf6 <- runif(sample_size, min = -3, max = 3)
    confounders = cbind(cf, cf5, cf6)
    colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
    rbindlist(lapply(c(1:4), function(gps_mod){
      if (gps_mod == 1) {
              exposure = scale_exposure(cov_function(confounders)) + rnorm(sample_size, mean = 0, sd = sqrt(10))
            } else if (gps_mod == 2) {
              exposure = scale_exposure(cov_function(confounders)) + (sqrt(5)) * rt(sample_size, df = 3)
            } else if (gps_mod == 3) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2) + rnorm(sample_size, mean = 0, sd = sqrt(10))
            } else if (gps_mod == 4) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"])) + rnorm(sample_size, mean = 0, sd = sqrt(10))
            }
    
    data = data.table(cbind(exposure, confounders))
    lm_model <- lm(exposure ~ cf1 + cf2 + cf3 + cf4 + cf5 + cf6, data = data)
    data.table(gps_mod = gps_mod, r_squared = summary(lm_model)$adj.r.squared)
    }))
  }))

r_squared %>%
  dplyr::group_by(gps_mod) %>%
  dplyr::summarize(mean = mean(r_squared),
                   lower = quantile(r_squared, 0.1),
                   upper = quantile(r_squared, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear",
                                    gps_mod == 2 ~ "heavy tail",
                                    gps_mod == 3 ~ "nonlinear",
                                    gps_mod == 4 ~ "interaction"),
                          levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>%
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, 
                      x = factor(gps_mod)), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Adjusted r squared", title = "Adjusted r-squared with noise term") + 
  theme_bw() +
  coord_cartesian(ylim = c(0, 1))

# Graph of the exposure's
    sample_size = 1000
    cf <- mvrnorm(n = sample_size,
                      mu = rep(0, 4),
                      Sigma = diag(4))
    cf5 <- sample(c((-2):2), sample_size, replace = T)
    cf6 <- runif(sample_size, min = -3, max = 3)
    confounders = cbind(cf, cf5, cf6)
    colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
    exposure1 = scale_exposure(cov_function(confounders)) + rnorm(sample_size, mean = 0, sd = sqrt(10))
    exposure2 = scale_exposure(cov_function(confounders)) + (sqrt(5)) * rt(sample_size, df = 3)
    exposure3 = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2) + rnorm(sample_size, mean = 0, sd = sqrt(10))
    exposure4 = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"])) + rnorm(sample_size, mean = 0, sd = sqrt(10))
    
  data.frame(linear = exposure1, heavy = exposure2, nonlinear = exposure3, interaction = exposure4) %>% 
    pivot_longer(cols = c("linear", "heavy", "nonlinear", "interaction")) %>% 
    mutate(name = factor(name, levels = c("linear", "heavy", "nonlinear", "interaction"))) %>% 
    ggplot(aes(x = value, color = name)) + 
    geom_density()
  
  
  df <- data.frame(category=factor(rep(c("linear", "heavy", "nonlinear", "interaction"), each = 1000)),
                   value = c(exposure1, exposure2, exposure3, exposure4))
  ggplot(df, aes(x=value, color=category)) + 
  geom_density()
      
```

## Results

Our first simulation can compare without adjustment for covariates in the outcome model, where we show that the propensity score model outperforms substantially

Note that running the CausalGPS package in parallel requires that I do not use mclapply and instead parLapply for some reason... so now I am going to be switching over to that

```{r, echo = F, eval = T, cache = T}
set.seed(23)
source(paste0(repo_dir, "/simulation_functions.R"))
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))
scale_exposure <- function(x){20 * (x-min(x))/(max(x)-min(x))}

sample_size = 2000
final_sample_size = 1000
med_pred_sample <- list()
med_pred_gps <- list()

# Iterate through several simulations
for (sim in 1:10) {
  cf <- mvrnorm(n = sample_size,
                mu = rep(0, 4),
                Sigma = diag(4))
  cf5 <- sample(c((-2):2), sample_size, replace = T)
  cf6 <- runif(sample_size, min = -3, max = 3)
  confounders = cbind(cf, cf5, cf6)
  colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
  # Loop through all GPS mods
  med_pred_gps[[sim]] <- list()
  for (gps_mod in 1:4) {
    # Generate appropriate exposure (make this a function later)
      if (gps_mod == 1) {
        exposure = scale_exposure(cov_function(confounders)) + rnorm(sample_size, mean = 0, sd = sqrt(10))
      } else if (gps_mod == 2) {
        exposure = scale_exposure(cov_function(confounders)) + (sqrt(5)) * rt(sample_size, df = 3)
      } else if (gps_mod == 3) {
        exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2) + rnorm(sample_size, mean = 0, sd = sqrt(10))
      } else if (gps_mod == 4) {
        exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"])) + rnorm(sample_size, mean = 0, sd = sqrt(10))
      }
    
    # Make sure all positive for sublinear
    final_cfd_exp <- data.frame(cbind(confounders, exposure)) %>% filter(exposure > 0)
    final_cfd_exp <- final_cfd_exp[1:final_sample_size, ]
    exposure <- final_cfd_exp$exposure
    confounders <- final_cfd_exp[, 1:6]
             
      # Get metrics and predictions from sample
      metrics_predictions <- 
        metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "sublinear",
                          outcome_relationship = "linear", sample_size = final_sample_size, family = "gaussian", adjust_confounder = T, causal_gps = T)
      
      metrics <- metrics_predictions$metrics
      predictions <-  metrics_predictions$predictions
      cor_table <- metrics_predictions$cor_table
      
      # Add appropriate columns
      metrics <- metrics %>% mutate(gps_mod = gps_mod, sample_size = final_sample_size, sim = sim)
      predictions <- predictions %>% mutate(gps_mod = gps_mod, sample_size = final_sample_size, sim = sim)
      
      # put method for correlation table
      cor_table <- cor_table %>% mutate(method = "ipw", delta = 0)
      
      # Add on correlation from causalgps package
      cor_default <-
        data.table(covariate = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6"),
                   pre_cor = metrics_predictions[[4]]$original_corr_results$absolute_corr,
                   post_cor = metrics_predictions[[4]]$adjusted_corr_results$absolute_corr,
                   method = "causal_gps_default",
                   delta =  metrics_predictions[[4]]$params$delta_n)
      
      cor_tuned <-
        data.table(covariate = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6"),
                   pre_cor = metrics_predictions[[5]]$original_corr_results$absolute_corr,
                   post_cor = metrics_predictions[[5]]$adjusted_corr_results$absolute_corr,
                   method = "causal_gps_tuned",
                   delta =  metrics_predictions[[5]]$params$delta_n)
      
      cor_table <- rbind(cor_table, cor_default, cor_tuned)
      cor_table <- cor_table %>% mutate(gps_mod = gps_mod, sample_size = final_sample_size, sim = sim)
      
      # Store in list
      med_pred_gps[[sim]][[gps_mod]] <- list(data.table(metrics),data.table(predictions), data.table(cor_table))
    }
  
  # Unpack list 
  metrics_gps <-rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[1]]))
  predictions_gps <- rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[2]]))
  correlation_gps <- rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[3]]))
  
  med_pred_sample[[sim]] <- list(metrics_gps, predictions_gps, correlation_gps)
}

# Save files and make way date stamp them soon
saveRDS(med_pred_sample, file = paste0(repo_dir, "med_pred_sample_sublinear_adjust.RDS"))

# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)

data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation_ipw <-
  gps_correlation %>% 
  filter(method == "ipw") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for IPW")
gg_correlation_ipw

gg_correlation_default <-
  gps_correlation %>% 
  filter(method == "causal_gps_default") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for causal GPS default")
    
gg_correlation_default

gg_correlation_tuned <-
  gps_correlation %>% 
  filter(method == "causal_gps_tuned") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for causal GPS default")
    
gg_correlation_tuned

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "causal_gps_default", "causal_gps_tuned", "change_model", "propensity_change")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(-10, 10)) + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(0, 35)) + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 200)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "causal_gps_default", "causal_gps_tuned", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "causal_gps_default", "causal_gps_tuned", "change_model", "propensity_change", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()
  


ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-20, 20)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

```
Now we if we adjust for confounders (in this case the propensity score models would be doubly robust)

```{r, echo = F, eval = T, cache = T}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

sample_size = 1000
med_pred_sample <- list()
med_pred_gps <- list()

# Iterate through several simulations
for (sim in 6:10) {
  cf <- mvrnorm(n = sample_size,
                mu = rep(0, 4),
                Sigma = diag(4))
  cf5 <- sample(c((-2):2), sample_size, replace = T)
  cf6 <- runif(sample_size, min = -3, max = 3)
  confounders = cbind(cf, cf5, cf6)
  colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
  # Loop through all GPS mods
  med_pred_gps[[sim]] <- list()
  for (gps_mod in 1:4) {
    # Generate appropriate exposure (make this a function later)
      if (gps_mod == 1) {
        exposure = scale_exposure(cov_function(confounders)) + rnorm(sample_size, mean = 0, sd = sqrt(10))
      } else if (gps_mod == 2) {
        exposure = scale_exposure(cov_function(confounders)) + (sqrt(5)) * rt(sample_size, df = 3)
      } else if (gps_mod == 3) {
        exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2) + rnorm(sample_size, mean = 0, sd = sqrt(10))
      } else if (gps_mod == 4) {
        exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"])) + rnorm(sample_size, mean = 0, sd = sqrt(10))
        }
             
      # Get metrics and predictions from sample
      metrics_predictions <- 
        metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "linear",
                          outcome_relationship = "linear", sample_size = sample_size, family = "gaussian", adjust_confounder = T, causal_gps = T)
      
      metrics <- metrics_predictions$metrics
      predictions <-  metrics_predictions$predictions
      cor_table <- metrics_predictions$cor_table
      
      # Add appropriate columns
      metrics <- metrics %>% mutate(gps_mod = gps_mod, sample_size = sample_size, sim = sim)
      predictions <- predictions %>% mutate(gps_mod = gps_mod, sample_size = sample_size, sim = sim)
      
      # put method for correlation table
      cor_table <- cor_table %>% mutate(method = "ipw", delta = 0)
      
      # Add on correlation from causalgps package
      cor_default <-
        data.table(covariate = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6"),
                   pre_cor = metrics_predictions[[4]]$original_corr_results$absolute_corr,
                   post_cor = metrics_predictions[[4]]$adjusted_corr_results$absolute_corr,
                   method = "causal_gps_default",
                   delta =  metrics_predictions[[4]]$params$delta_n)
      
      cor_tuned <-
        data.table(covariate = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6"),
                   pre_cor = metrics_predictions[[5]]$original_corr_results$absolute_corr,
                   post_cor = metrics_predictions[[5]]$adjusted_corr_results$absolute_corr,
                   method = "causal_gps_tuned",
                   delta =  metrics_predictions[[5]]$params$delta_n)
      
      cor_table <- rbind(cor_table, cor_default, cor_tuned)
      cor_table <- cor_table %>% mutate(gps_mod = gps_mod, sample_size = sample_size, sim = sim)
      
      # Store in list
      med_pred_gps[[sim]][[gps_mod]] <- list(data.table(metrics),data.table(predictions), data.table(cor_table))
    }
  
  # Unpack list 
  metrics_gps <-rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[1]]))
  predictions_gps <- rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[2]]))
  correlation_gps <- rbindlist(lapply(med_pred_gps[[sim]], function(x) x[[3]]))
  
  med_pred_sample[[sim]] <- list(metrics_gps, predictions_gps, correlation_gps)
}

# Save files and make way date stamp them soon
saveRDS(med_pred_sample, file = paste0("~/Desktop/Francesca_research/Simulation_studies/med_pred_sample_linear.RDS"))


# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)

data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation_ipw <-
  gps_correlation %>% 
  filter(method == "ipw") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for IPW")
gg_correlation_ipw

gg_correlation_default <-
  gps_correlation %>% 
  filter(method == "causal_gps_default") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for causal GPS default")
    
gg_correlation_default

gg_correlation_tuned <-
  gps_correlation %>% 
  filter(method == "causal_gps_tuned") %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings for causal GPS default")
    
gg_correlation_tuned

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "causal_gps_default", "causal_gps_tuned", "change_model", "propensity_change")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(-10, 10)) + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(0, 35)) + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 200)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "causal_gps_default", "causal_gps_tuned", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "causal_gps_default", "causal_gps_tuned", "change_model", "propensity_change", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()
  


ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-10, 10)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

```




## Nonlinear scenario (supralinear)

We repeat our analysis with a nonlinear relationship between the exposure and outcome to compare how these methods perform. The outcome model we fit is described below:


$$
\begin{split} 
Y|E,C &\sim N(\mu(E, C), 10^2) \\
\mu(E, C) &= 20 + 8*log_{10}(E + 1) - (2, 2, 3, -1, 2, 2)*C 
\end{split}
$$

```{r, eval = T, echo = F, cache = T}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

med_pred_sample <- 
  lapply(c(1000), function(sample_size){
    # Iterate through several simulations
    med_pred_sim <- 
      mclapply(c(1:10), mc.cores = 10, function(sim) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
        med_pred_gps <- 
          lapply(c(1:4), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = scale_exposure(cov_function(confounders)) + abs(rnorm(sample_size, mean = 0, sd = 3))
            } else if (gps_mod == 2) {
              exposure = scale_exposure(cov_function(confounders)) + abs(rt(sample_size, df = 2))
            } else if (gps_mod == 3) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^2) + abs(rnorm(sample_size, mean = 0, sd = 3))
            } else if (gps_mod == 4) {
              exposure = scale_exposure(cov_function(confounders) + 0.5 * (confounders[, "cf3"]) ^ 2 + 0.5 * (confounders[, "cf1"]) * (confounders[, "cf5"])) + abs(rnorm(sample_size, mean = 0, sd = 3))
            }
             
            
            # Get metrics and predictions from sample
            metrics_predictions <- 
              metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "linear", 
                                outcome_relationship = "linear", sample_size = sample_size, family = "gaussian", adjust_confounder = T)
    
            metrics <- metrics_predictions$metrics
            predictions <-  metrics_predictions$predictions
            cor_table <- metrics_predictions$cor_table
            
            metrics[, gps_mod := gps_mod]
            metrics[, sample_size := sample_size]
            metrics[, sim := sim]
            
            predictions[, gps_mod := gps_mod]
            predictions[, sample_size := sample_size]
            predictions[, sim := sim]
            
            cor_table[, gps_mod := gps_mod]
            cor_table[, sample_size := sample_size]
            cor_table[, sim := sim]
            
            return(list(metrics, predictions, cor_table))
          })
        
        metrics_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[1]]))
        predictions_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[2]]))
        correlation_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[3]]))
        
        return(list(metrics_gps, predictions_gps, correlation_gps))
      })
    metrics_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[1]]))
    predictions_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[2]]))
    correlation_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[3]]))
    return(list(metrics_sim, predictions_sim, correlation_sim))
  })

# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)

data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation <-
  gps_correlation %>% 
  group_by(gps_mod, covariate) %>% 
  dplyr::summarize(pre_weight = mean(pre_cor), post_weight = mean(post_cor)) %>% 
  pivot_longer(c("pre_weight", "post_weight")) %>%
  mutate(name = factor(name, levels = unique(name))) %>%
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(y = "Absolute correlation", x = "Covariate", title = "Comparing covariate balance under different design settings")
    
gg_correlation

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(-10, 10)) + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(0, 35)) + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 200)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "change_model", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()


ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-10, 10)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

```
```


## Threshold model 

Finally we fit a threshold model and repeat our analysis. The following outcome model is fit:

$$
\begin{split} 
Y|E,C &\sim N(\mu(E, C), 10^2) \\
\mu(E, C) &= 20 + E[E > 5] - (2, 2, 3, -1, 2, 2)*C 
\end{split}
$$

I am fitting a hinge threshold here, which is the correctly identified case here. Information on how this is fit can be found [here](https://mran.microsoft.com/snapshot/2020-04-27/web/packages/chngpt/vignettes/chngpt-vignette.pdf).

```{r, eval = T, echo = F, cache = T}
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

med_pred_sample <- 
  lapply(c(1000), function(sample_size){
    # Iterate through several simulations
    med_pred_sim <- 
      mclapply(c(1:100), mc.cores = 10, function(sim) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
        med_pred_gps <- 
          lapply(c(1:4), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = 9 * cov_function(confounders) + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 2) {
              exposure = 15 *  cov_function(confounders) + rt(sample_size, df = 2)
            } else if (gps_mod == 3) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 4) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + 2 * (confounders[, "cf1"]) * (confounders[, "cf6"]) + rnorm(sample_size, mean = 0, sd = 5)
            }
            
            # Rescale exposure to lie between 0-20
            scale_exposure <- function(x) {
              20 * (x - min(x)) / (max(x) - min(x))
            }
            exposure = scale_exposure(exposure)
            
            # Get metrics and predictions from sample
            metrics_predictions <- 
              metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "threshold", 
                                outcome_relationship = "linear", sample_size = sample_size, family = "gaussian", adjust_confounder = T)
    
            metrics <- metrics_predictions$metrics
            predictions <-  metrics_predictions$predictions
            cor_table <- metrics_predictions$cor_table
            
            metrics[, gps_mod := gps_mod]
            metrics[, sample_size := sample_size]
            metrics[, sim := sim]
            
            predictions[, gps_mod := gps_mod]
            predictions[, sample_size := sample_size]
            predictions[, sim := sim]
            
            cor_table[, gps_mod := gps_mod]
            cor_table[, sample_size := sample_size]
            cor_table[, sim := sim]
            
            return(list(metrics, predictions, cor_table))
          })
        
        metrics_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[1]]))
        predictions_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[2]]))
        correlation_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[3]]))
        
        return(list(metrics_gps, predictions_gps, correlation_gps))
      })
    metrics_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[1]]))
    predictions_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[2]]))
    correlation_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[3]]))
    return(list(metrics_sim, predictions_sim, correlation_sim))
  })

# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)
data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation <-
  gps_correlation %>% 
   group_by(gps_mod, covariate) %>% 
   dplyr::summarize(pre_cor = mean(pre_cor),
             post_cor = mean(post_cor)) %>% 
   pivot_longer(c("pre_cor", "post_cor")) %>%
   mutate(name = factor(name, levels = unique(name))) %>%
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(x = "Absolute correlation", y = "Covariate", title = "Comparing covariate balance with nonlinear")
    
#gg_correlation  

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(-10, 10)) + 
  theme_bw() + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(0, 35)) + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 200)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

pred_summary <- 
  pred_summary %>% 
  mutate(name = as.character(name)) %>%
  mutate(name = ifelse(name == "change_model",  "threshold", name)) %>% 
  mutate(name = ifelse(name == "propensity_change",  "threshold_gps", name)) %>% 
  mutate(name = factor(name)) %>% 
  data.table()
                             

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

pred_sample <- 
  pred_sample %>% 
  mutate(name = as.character(name)) %>%
  mutate(name = ifelse(name == "change_model",  "threshold", name)) %>% 
  mutate(name = ifelse(name == "propensity_change",  "threshold_gps", name)) %>% 
  mutate(name = factor(name)) %>% 
  data.table()
                    

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()
  

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = mean), linetype = "dashed") +
#    geom_line(data = true_fit_plot[gps_mod == 1], aes(x = exposure, y = mean), color = "black", linetype = "solid") +
#     geom_line(data = pred_sample[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   facet_grid(sample_size ~ name, scales = "free") + 
#   theme(legend.position = "none")



ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-10, 25)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

save_plot <- 
  ggplot() +
  geom_line(data = pred_summary[name %in% c("linear_model", "gam_model", "threshold", "threshold_gps") & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name %in% c("linear_model", "gam_model", "threshold", "threshold_gps") & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-10, 25)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none") + 
  theme( axis.text = element_text( size = 18 ),
           axis.text.x = element_text( size = 20 ),
           axis.title = element_text( size = 20, face = "bold" ),
           legend.position="none",
           # The new stuff
           strip.text = element_text(size = 20))

ggsave(
  "~/Desktop/Francesca_research/Simulation_studies/poster_plot.pdf",
  plot = save_plot,
  device = NULL,
  path = NULL,
  scale = 1,
  width = 12,
  height = 10,
  units = "in",
  dpi = 300,
  limitsize = TRUE,
  bg = NULL,
)

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = mean), linetype = "solid") +
#    geom_line(data = true_fit_plot[sample_size == 1000 & gps_mod %in% c(4,5,6)], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
#     geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   #coord_cartesian(ylim = c(-6, 6)) + 
#   facet_grid(name ~ gps_mod) + 
#   theme(legend.position = "none")
# 

# plot_data %>%
#   ggplot() +
#   geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
#   geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) +
#   labs(x = "Scenario", y = "Value") +
#   theme_bw() +
#   facet_grid(sample_size ~ name)


# sim_data %>%
#   dplyr::select(gps_mod, sample_size, model, bias, mse) %>%
#   arrange(gps_mod, sample_size) %>%
#   knitr::kable()


```

\newpage
## Nonlinearity in outcome model 

$$
\begin{split} 
Y|E,C &\sim N(\mu(E, C), 10^2) \\
\mu(E, C) &= 20 + 0.1*E -C_1^3 - C_1 + exp(C_2 - C_6) + log(|C_2| * |C_3|)
\end{split}
$$

```{r, echo = F, eval = T, cache = T}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

med_pred_sample <- 
  lapply(c(1000), function(sample_size){
    # Iterate through several simulations
    med_pred_sim <- 
      mclapply(c(1:100), mc.cores = 10, function(sim) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
        med_pred_gps <- 
          lapply(c(1:4), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = 9 * cov_function(confounders) + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 2) {
              exposure = 15 *  cov_function(confounders) + rt(sample_size, df = 2)
            } else if (gps_mod == 3) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 4) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + 2 * (confounders[, "cf1"]) * (confounders[, "cf6"]) + rnorm(sample_size, mean = 0, sd = 5)
            }
            
            # Rescale exposure to lie between 0-20
            scale_exposure <- function(x) {
              20 * (x - min(x)) / (max(x) - min(x))
            }
            exposure = scale_exposure(exposure)
            
            
            # Get metrics and predictions from sample
            metrics_predictions <- 
              metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "linear", 
                                outcome_relationship = "nonlinear", sample_size = sample_size, family = "gaussian", adjust_confounder = T)
    
            metrics <- metrics_predictions$metrics
            predictions <-  metrics_predictions$predictions
            cor_table <- metrics_predictions$cor_table
            
            metrics[, gps_mod := gps_mod]
            metrics[, sample_size := sample_size]
            metrics[, sim := sim]
            
            predictions[, gps_mod := gps_mod]
            predictions[, sample_size := sample_size]
            predictions[, sim := sim]
            
            cor_table[, gps_mod := gps_mod]
            cor_table[, sample_size := sample_size]
            cor_table[, sim := sim]
            
            return(list(metrics, predictions, cor_table))
          })
        
        metrics_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[1]]))
        predictions_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[2]]))
        correlation_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[3]]))
        
        return(list(metrics_gps, predictions_gps, correlation_gps))
      })
    metrics_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[1]]))
    predictions_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[2]]))
    correlation_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[3]]))
    return(list(metrics_sim, predictions_sim, correlation_sim))
  })

# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)

data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation <-
  gps_correlation %>% 
   group_by(gps_mod, covariate) %>% 
   dplyr::summarize(pre_cor = mean(pre_cor),
             post_cor = mean(post_cor)) %>% 
   pivot_longer(c("pre_cor", "post_cor")) %>%
   mutate(name = factor(name, levels = unique(name))) %>%
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(x = "Absolute correlation", y = "Covariate", title = "Comparing covariate balance with nonlinear")
    
gg_correlation

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(-10, 10)) + 
  theme_bw() + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  coord_cartesian(ylim = c(0, 35)) + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 500)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_model", "gam_gps", "change_model", "propensity_change", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()
  

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = mean), linetype = "dashed") +
#    geom_line(data = true_fit_plot[gps_mod == 1], aes(x = exposure, y = mean), color = "black", linetype = "solid") +
#     geom_line(data = pred_sample[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   facet_grid(sample_size ~ name, scales = "free") + 
#   theme(legend.position = "none")


ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-15, 15)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = mean), linetype = "solid") +
#    geom_line(data = true_fit_plot[sample_size == 1000 & gps_mod %in% c(4,5,6)], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
#     geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   #coord_cartesian(ylim = c(-6, 6)) + 
#   facet_grid(name ~ gps_mod) + 
#   theme(legend.position = "none")


# plot_data %>%
#   ggplot() +
#   geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
#   geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) +
#   labs(x = "Scenario", y = "Value") +
#   theme_bw() +
#   facet_grid(sample_size ~ name)


# sim_data %>%
#   dplyr::select(gps_mod, sample_size, model, bias, mse) %>%
#   arrange(gps_mod, sample_size) %>%
#   knitr::kable()

```

\newpage

$$
\begin{split} 
Y|E,C &\sim N(\mu(E, C), 10^2) \\
\mu(E, C) &= 20 + 8*log_{10}(E + 1) - C_1^3 - C_1 + exp(C_2 - C_6) + log(|C_2| * |C_3|)
\end{split}
$$

```{r, echo = F, eval = T, cache = T}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

med_pred_sample <- 
  lapply(c(1000), function(sample_size){
    # Iterate through several simulations
    med_pred_sim <- 
      mclapply(c(1:100), mc.cores = 10, function(sim) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
      
        med_pred_gps <- 
          lapply(c(1:4), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = 9 * cov_function(confounders) + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 2) {
              exposure = 15 *  cov_function(confounders) + rt(sample_size, df = 2)
            } else if (gps_mod == 3) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 4) {
              exposure = 7 * cov_function(confounders) + (confounders[, "cf3"]) ^ 2 + 2 * (confounders[, "cf1"]) * (confounders[, "cf6"]) + rnorm(sample_size, mean = 0, sd = 5)
            }
            
            # Rescale exposure to lie between 0-20
            scale_exposure <- function(x) {
              20 * (x - min(x)) / (max(x) - min(x))
            }
            exposure = scale_exposure(exposure)
            
            
            # Get metrics and predictions from sample
            metrics_predictions <- 
              metrics_from_data(exposure = exposure, confounders = confounders, exposure_relationship = "sublinear", 
                                outcome_relationship = "nonlinear", sample_size = sample_size, family = "gaussian", adjust_confounder = T)
    
            metrics <- metrics_predictions$metrics
            predictions <-  metrics_predictions$predictions
            cor_table <- metrics_predictions$cor_table
            
            metrics[, gps_mod := gps_mod]
            metrics[, sample_size := sample_size]
            metrics[, sim := sim]
            
            predictions[, gps_mod := gps_mod]
            predictions[, sample_size := sample_size]
            predictions[, sim := sim]
            
            cor_table[, gps_mod := gps_mod]
            cor_table[, sample_size := sample_size]
            cor_table[, sim := sim]
            
            return(list(metrics, predictions, cor_table))
          })
        
        metrics_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[1]]))
        predictions_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[2]]))
        correlation_gps <- rbindlist(lapply(med_pred_gps, function(x) x[[3]]))
        
        return(list(metrics_gps, predictions_gps, correlation_gps))
      })
    metrics_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[1]]))
    predictions_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[2]]))
    correlation_sim <- rbindlist(lapply(med_pred_sim, function(x) x[[3]]))
    return(list(metrics_sim, predictions_sim, correlation_sim))
  })

# Unpack the metrics and predictions
metrics <- rbindlist(lapply(med_pred_sample, function(x) x[[1]]))
predictions <- rbindlist(lapply(med_pred_sample, function(x) x[[2]]))
gps_correlation <- rbindlist(lapply(med_pred_sample, function(x) x[[3]]))

# Graph the chain points found 
change_points = unique(predictions$change_point)

data.table(change_points) %>% 
  ggplot() + 
  geom_histogram(aes(x = change_points), bins = 20) + 
  theme_classic() + 
  labs(x = "Change point", y = "Count", title = "Change point distribution")


gg_correlation <-
  gps_correlation %>% 
   group_by(gps_mod, covariate) %>% 
   dplyr::summarize(pre_cor = mean(pre_cor),
             post_cor = mean(post_cor)) %>% 
   pivot_longer(c("pre_cor", "post_cor")) %>%
   mutate(name = factor(name, levels = unique(name))) %>%
   ggplot(aes(x = covariate, y = value, color = name, group = name)) +
   geom_hline(aes(yintercept = 0.1)) + 
   geom_point() +
   geom_line() +
   theme_bw() +
   coord_flip() + 
   facet_wrap(~ gps_mod) + 
   labs(x = "Absolute correlation", y = "Covariate", title = "Comparing covariate balance with nonlinear")
    
gg_correlation

plot_data <- 
  metrics %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(model = factor(model, levels = c("linear_model", "linear_gps", "linear_gps_nocf", "gam_model", "gam_gps", "gam_gps_nocf", "change_model")))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9)) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction")))

plot_data %>% 
  filter(name == "bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_wrap(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse", sample_size == 1000) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.6)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype = "dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  coord_cartesian(ylim = c(0, 100)) + 
  facet_grid(sample_size ~ name, scales = "free")

# Make prediction plots
pred_plot <-
  predictions %>%
  tidyr::pivot_longer(c("linear_model", "linear_gps", "gam_model", "change_model", "true_fit")) %>%
  mutate(name = factor(name, levels = c("linear_model", "linear_gps", "gam_gps", "change_model", "true_fit"))) %>% 
  data.table()

pred_summary <-
  pred_plot[,.(mean = mean(value),
             lower = quantile(value, 0.1),
             upper = quantile(value, 0.9)), by=.(gps_mod, exposure, sample_size, name)] %>% 
  mutate(name = relevel(name, ref = "linear_model")) %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

# Get a sample of predictions to plot
pred_sample <- 
  pred_plot[sim %in% sample(1:20, 10, replace = F)] %>% 
  mutate(gps_mod = factor(case_when(gps_mod == 1 ~ "linear", 
                             gps_mod == 2 ~ "heavy tail", 
                             gps_mod == 3 ~ "nonlinear", 
                             gps_mod == 4 ~ "interaction"), levels = c("linear", "heavy tail", "nonlinear", "interaction"))) %>% 
  data.table()

true_fit_plot <- pred_summary[name == "true_fit"] %>% dplyr::select(-name) %>% data.table()
  

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = mean), linetype = "dashed") +
#    geom_line(data = true_fit_plot[gps_mod == 1], aes(x = exposure, y = mean), color = "black", linetype = "solid") +
#     geom_line(data = pred_sample[name != "true_fit" & gps_mod == 1], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   facet_grid(sample_size ~ name, scales = "free") + 
#   theme(legend.position = "none")


ggplot() +
  geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = mean), linetype = "solid") +
  geom_line(data = true_fit_plot[sample_size == 1000], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
  geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
  scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
  labs(x = "Exposure", y = "Response") +
  theme_bw() +
  coord_cartesian(ylim = c(-15, 15)) + 
  facet_grid(name ~ gps_mod) + 
  theme(legend.position = "none")

# ggplot() +
#   geom_line(data = pred_summary[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = mean), linetype = "solid") +
#    geom_line(data = true_fit_plot[sample_size == 1000 & gps_mod %in% c(4,5,6)], aes(x = exposure, y = mean), color = "black", linetype = "dashed") +
#     geom_line(data = pred_sample[name != "true_fit" & sample_size == 1000 & gps_mod %in% c(4, 5, 6)], aes(x = exposure, y = value, color = factor(sim)), linetype = "solid", alpha = 0.5) + 
#   scale_color_manual(values = c("gray", "gray","gray", "gray", "gray", "gray", "gray", "gray", "gray", "gray")) + 
#   labs(x = "Exposure", y = "Response") +
#   theme_bw() +
#   #coord_cartesian(ylim = c(-6, 6)) + 
#   facet_grid(name ~ gps_mod) + 
#   theme(legend.position = "none")


# plot_data %>%
#   ggplot() +
#   geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
#   geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) +
#   labs(x = "Scenario", y = "Value") +
#   theme_bw() +
#   facet_grid(sample_size ~ name)


# sim_data %>%
#   dplyr::select(gps_mod, sample_size, model, bias, mse) %>%
#   arrange(gps_mod, sample_size) %>%
#   knitr::kable()

```

# End of document 

\newpage



```{r, echo = F, cache = T, eval = F}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

sim_data <- 
  rbindlist(lapply(c(200, 1000), function(sample_size){
    # Iterate through several simulations
    rbindlist(mclapply(c(1:100), mc.cores = 10, function(sim) {
      cf <- mvrnorm(n = sample_size,
                  mu = rep(0, 4),
                  Sigma = diag(4))
      cf5 <- sample(c((-2):2), sample_size, replace = T)
      cf6 <- runif(sample_size, min = -3, max = 3)
      confounders = cbind(cf, cf5, cf6)
      colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
    
      sim_data <- 
        rbindlist(lapply(c(1:6), function(gps_mod) {
          if (gps_mod == 1) {
            exposure = 9 * cov_function(confounders) + 17 + rnorm(sample_size, mean = 0, sd =  5)
          } else if (gps_mod == 2) {
            exposure = 15 *  cov_function(confounders) + 17 + rt(sample_size, df = 2)
          } else if (gps_mod == 3) {
            exposure = 9 * cov_function(confounders) + 3/2* (confounders[, "cf3"])^2 + 15 + rnorm(sample_size, mean = 0, sd =  5)
          } else if (gps_mod == 4) {
            exposure = 49 * exp(cov_function(confounders)) / (1 + exp(cov_function(confounders))) - 6 + rnorm(sample_size, mean = 0, sd = 5)
          } else if (gps_mod == 5) {
            exposure = 42 * 1 / (1 + exp(cov_function(confounders))) - 18 + rnorm(sample_size, mean = 0, sd = 5)
          } else if (gps_mod == 6) {
            exposure = 7 * log(abs(cov_function(confounders))) + 13 + rnorm(sample_size, mean = 0, sd = 4)
          }
          
          final_results <- 
            metrics_from_data(exposure = exposure, confounders = confounders, relationship = "linear", 
                              sample_size = sample_size, family = "gaussian", adjust_confounder = T)$metrics
          
          final_results[, gps_mod := gps_mod]
          final_results[, sample_size := sample_size]
          final_results[, sim := sim]
          return(final_results)
        }))
      return(sim_data)
    }))
  }))

# Working here on getting that data working, so far now luck 

 # sim_data <-
 #  sim_data %>%
 #  mutate(bias = abs(bias))
 
plot_data <- 
  sim_data %>% 
  mutate(bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "mse")) %>% 
  mutate(name = factor(name))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9))

# Now make the correct boxplot to compare the results 
# What is the metric being used by Boyu? 

levels(plot_data$name) <- c("Bias", "MSE")

plot_data %>% 
  filter(name == "Bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "Bias", gps_mod != 2) %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")


plot_data %>% 
  filter(name == "MSE") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

# plot_data %>% 
#   ggplot() + 
#   geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
#   geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
#   labs(x = "Scenario", y = "Value") + 
#   theme_bw() + 
#   facet_grid(sample_size ~ name)

```

## No noise term 
Now I fit without any noise terms included in the model
```{r, echo = F, cache = T, eval = F}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

sim_data <- 
  rbindlist(lapply(c(200, 1000), function(sample_size){
    # Iterate through several simulations
    rbindlist(mclapply(c(1:100), mc.cores = 10, function(sim) {
      cf <- mvrnorm(n = sample_size,
                  mu = rep(0, 4),
                  Sigma = diag(4))
      cf5 <- sample(c((-2):2), sample_size, replace = T)
      cf6 <- runif(sample_size, min = -3, max = 3)
      confounders = cbind(cf, cf5, cf6)
      colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
    
      sim_data <- 
        rbindlist(lapply(c(1:6), function(gps_mod) {
          if (gps_mod == 1) {
            exposure = 9 * cov_function(confounders) + 17 
          } else if (gps_mod == 2) {
            exposure = 15 *  cov_function(confounders) + 17 
          } else if (gps_mod == 3) {
            exposure = 9 * cov_function(confounders) + 3/2* (confounders[, "cf3"])^2 + 15
          } else if (gps_mod == 4) {
            exposure = 49 * exp(cov_function(confounders)) / (1 + exp(cov_function(confounders))) - 6
          } else if (gps_mod == 5) {
            exposure = 42 * 1 / (1 + exp(cov_function(confounders))) - 18 
          } else if (gps_mod == 6) {
            exposure = 7 * log(abs(cov_function(confounders))) + 13
          }
          
          final_results <- 
            metrics_from_data(exposure = exposure, confounders = confounders, relationship = "linear", 
                              sample_size = sample_size, family = "gaussian", adjust_confounder = T)$metrics
          
          final_results[, gps_mod := gps_mod]
          final_results[, sample_size := sample_size]
          final_results[, sim := sim]
          return(final_results)
        }))
      return(sim_data)
    }))
  }))

# Working here on getting that data working, so far now luck 

 # sim_data <-
 #  sim_data %>%
 #  mutate(bias = abs(bias))
 
plot_data <- 
  sim_data %>% 
  mutate(absolute_bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "absolute_bias", "mse")) %>% 
  mutate(name = factor(name))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, name) %>% 
  dplyr::summarize(mean = mean(value), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9))

# Now make the correct boxplot to compare the results 
# What is the metric being used by Boyu? 

#levels(plot_data$name) <- c("Bias","Absolute_Bias", "MSE")

plot_data %>% 
  filter(name == "bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "absolute_bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")

plot_data %>% 
  filter(name == "mse") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) +
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(sample_size ~ name, scales = "free")
```

### Increase effect of confounding 

Now we adjust for the ratio between the standard deviation of the exposure and the standard deviation of the confounding, keeping the exposure relationship constant at 0.1. Here we don't adjust for confounders at all. Smaller values for this ratio indicate that the standard deviation of the confounding is much larger than the effect of the exposure. 

```{r, cache = T, echo = F, eval = F}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

adjusted_sim <- 
  rbindlist(lapply(c(200), function(sample_size){
    # Iterate through several simulations
    rbindlist(mclapply(c(1:100), function(sim) {
      # Iterate through ratio of exposure and confounder
      rbindlist(lapply(c(1, 0.1, 0.01), function(exposure_confounder_ratio) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
          
        rbindlist(lapply(c(1:6), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = 9 * cov_function(confounders) + 17 + rnorm(sample_size, mean = 0, sd =  5)
            } else if (gps_mod == 2) {
              exposure = 15 *  cov_function(confounders) + 17 + rt(sample_size, df = 2)
            } else if (gps_mod == 3) {
              exposure = 9 * cov_function(confounders) + 3/2* (confounders[, "cf3"])^2 + 15 + rnorm(sample_size, mean = 0, sd =  5)
            } else if (gps_mod == 4) {
              exposure = 49 * exp(cov_function(confounders)) / (1 + exp(cov_function(confounders))) - 6 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 5) {
              exposure = 42 * 1 / (1 + exp(cov_function(confounders))) - 18 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 6) {
              exposure = 7 * log(abs(cov_function(confounders))) + 13 + rnorm(sample_size, mean = 0, sd = 4)
            }
            
            # Multiply confounder to get the correct ratio of confounding to sd exposure)
            confounder_mult <- sd(0.1 * exposure) / (sd(c(2, 2, 3, -1, -2, -2) %*% t(confounders))*exposure_confounder_ratio)
            # sd(0.1 * exposure) / sd((c(2, 2, 3, -1, -2, -2)) %*% t(confounders))
            # sd(0.1 * exposure) / sd((confounder_mult * c(2, 2, 3, -1, -2, -2)) %*% t(confounders))
            # sd(c(2, 2, 3, -1, -2, -2) %*% t(confounders))
            
            final_results <- 
              metrics_from_data(exposure = exposure, confounders = confounders, relationship = "linear",
                                sample_size = sample_size, family = "gaussian", adjust_confounder = F, 
                                confounder_mult = confounder_mult)$metrics
            
            final_results[, gps_mod := gps_mod]
            final_results[, sample_size := sample_size]
            final_results[, sim := sim]
            final_results[, exp_conf_ratio := exposure_confounder_ratio]
            return(final_results)
        }))
      }))
    }))
  }))

# Working here on getting that data working, so far now luck 

# adjusted_sim <-
#   adjusted_sim %>%
#   mutate(bias = abs(bias))
 
plot_data <- 
  adjusted_sim %>% 
  mutate(bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "mse")) %>% 
  mutate(name = factor(name))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, exp_conf_ratio, name) %>% 
  dplyr::summarize(mean = quantile(value, 0.5), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9))

# Now make the correct boxplot to compare the results 
# What is the metric being used by Boyu? 

levels(plot_data$name) <- c("Bias", "MSE")

plot_data %>% 
  filter(name == "Bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  geom_hline(yintercept=c(0), linetype="solid", size = 0.3) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(exp_conf_ratio ~ name, scales = "free")

plot_data %>% 
  filter(name == "MSE") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(exp_conf_ratio ~ name, scales = "free")

```


I then repeat with adjustment for linear confounding: 

```{r, cache = T, echo = F}
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

adjusted_sim <- 
  rbindlist(lapply(c(200), function(sample_size){
    # Iterate through several simulations
    rbindlist(mclapply(c(1:100), function(sim) {
      # Iterate through ratio of exposure and confounder
      rbindlist(lapply(c(1, 0.1, 0.01), function(exposure_confounder_ratio) {
        cf <- mvrnorm(n = sample_size,
                    mu = rep(0, 4),
                    Sigma = diag(4))
        cf5 <- sample(c((-2):2), sample_size, replace = T)
        cf6 <- runif(sample_size, min = -3, max = 3)
        confounders = cbind(cf, cf5, cf6)
        colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")
          
        rbindlist(lapply(c(1:6), function(gps_mod) {
            if (gps_mod == 1) {
              exposure = 9 * cov_function(confounders) + 17 + rnorm(sample_size, mean = 0, sd =  5)
            } else if (gps_mod == 2) {
              exposure = 15 *  cov_function(confounders) + 17 + rt(sample_size, df = 2)
            } else if (gps_mod == 3) {
              exposure = 9 * cov_function(confounders) + 3/2* (confounders[, "cf3"])^2 + 15 + rnorm(sample_size, mean = 0, sd =  5)
            } else if (gps_mod == 4) {
              exposure = 49 * exp(cov_function(confounders)) / (1 + exp(cov_function(confounders))) - 6 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 5) {
              exposure = 42 * 1 / (1 + exp(cov_function(confounders))) - 18 + rnorm(sample_size, mean = 0, sd = 5)
            } else if (gps_mod == 6) {
              exposure = 7 * log(abs(cov_function(confounders))) + 13 + rnorm(sample_size, mean = 0, sd = 4)
            }
            
            # Multiply confounder to get the correct ratio of confounding to sd exposure)
            confounder_mult <- sd(0.1 * exposure) / (sd(c(2, 2, 3, -1, -2, -2) %*% t(confounders))*exposure_confounder_ratio)
            # sd(0.1 * exposure) / sd((c(2, 2, 3, -1, -2, -2)) %*% t(confounders))
            # sd(0.1 * exposure) / sd((confounder_mult * c(2, 2, 3, -1, -2, -2)) %*% t(confounders))
            # sd(c(2, 2, 3, -1, -2, -2) %*% t(confounders))
            
            final_results <- 
              metrics_from_data(exposure = exposure, confounders = confounders, relationship = "linear",
                                sample_size = sample_size, family = "gaussian", adjust_confounder = T, 
                                confounder_mult = confounder_mult)$metrics
            
            final_results[, gps_mod := gps_mod]
            final_results[, sample_size := sample_size]
            final_results[, sim := sim]
            final_results[, exp_conf_ratio := exposure_confounder_ratio]
            return(final_results)
        }))
      }))
    }))
  }))

# Working here on getting that data working, so far now luck 

# adjusted_sim <-
#   adjusted_sim %>%
#   mutate(bias = abs(bias))
 
plot_data <- 
  adjusted_sim %>% 
  mutate(bias = abs(bias)) %>% 
  tidyr::pivot_longer(c("bias", "mse")) %>% 
  mutate(name = factor(name))  %>% 
  dplyr::group_by(model, gps_mod, sample_size, exp_conf_ratio, name) %>% 
  dplyr::summarize(mean = quantile(value, 0.5), 
            lower = quantile(value, 0.1),
            upper = quantile(value, 0.9))

# Now make the correct boxplot to compare the results 
# What is the metric being used by Boyu? 

levels(plot_data$name) <- c("Bias", "MSE")

plot_data %>% 
  filter(name == "Bias") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  geom_hline(yintercept=c(0), linetype="solid", size = 0.3) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(exp_conf_ratio ~ name, scales = "free")

plot_data %>% 
  filter(name == "MSE") %>% 
  ggplot() + 
  geom_pointrange(aes(y = mean, ymin = lower, ymax = upper, x = factor(gps_mod), color = model), position = position_dodge(.5)) + 
  geom_vline(xintercept=c(1.5, 2.5,3.5, 4.5, 5.5), linetype="dashed", size = 0.2) + 
  labs(x = "Scenario", y = "Value") + 
  theme_bw() + 
  facet_grid(exp_conf_ratio ~ name, scales = "free")

```






```{r, eval = F}
# Ignore this for now
sample_size = 200
cf <- mvrnorm(n = sample_size,
              mu = rep(0, 4),
              Sigma = diag(4))
cf5 <- sample(c((-2):2), sample_size, replace = T)
cf6 <- runif(sample_size, min = -3, max = 3)
confounders = cbind(cf, cf5, cf6)
colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")


sd(0.1 * exposure) / sd(c(2, 2, 3, -1, -2, -2) %*% t(confounders))
# Exposure is a 10th of the size of the residual confounding 
# Adjust that 0.1 and try .05 and try .01 and see how that impact the bias. Because 
# Include some sort of affect size for the exposure, see if affect bias a lot. Bias would get larger with smaller affect size of the exposure. 

c(2, 2, 3, -1, -2, -2) %*% t(confounders) %>% hist()



```


Now use GPS weighted adjustement as well: 

```{r, eval = F}
GPS_mod <- xgboost(data = data.matrix(covariates[, c(4:19)]), 
                   label = covariates$pm25_ensemble,
                   nrounds = 50)
mod_sd <- sd(covariates$pm25_ensemble - predict(GPS_mod, data.matrix(covariates[, c(4:19)])))
feature_names <- GPS_mod$feature_names
covariates$GPS <- dnorm(covariates$pm25_ensemble,
                        mean = predict(GPS_mod, data.matrix(covariates[, c(4:19)])),
                        sd = sd(covariates$pm25_ensemble - predict(GPS_mod, data.matrix(covariates[, c(4:19)]))))
Nm <- dnorm(covariates$pm25_ensemble,
            mean = mean(covariates$pm25_ensemble, na.rm = TRUE),
            sd = sd(covariates$pm25_ensemble, na.rm = TRUE))
covariates$IPW <- Nm / (covariates$GPS)
covariates <- covariates[, c("zip", "year", "IPW", "GPS")]

```



* Add causalGPS to type of fit here, and see how it does in terms of bias compared to others (should see difference since it is correctly accounting in all cases)

* Move to Poisson 

* Move forward on getting causalGPS package to work 

* Add more propensity score models to analysis 


```{r, echo = F, cache = F, eval = F}
# Eschif adds time to be around 1.4 minutes to complete
set.seed(23)
source("~/Desktop/Francesca_research/Simulation_studies/simulation_functions.R")
sample_size = 1000

# Delete in a bit
cf <- mvrnorm(n = sample_size,
              mu = rep(0, 4),
              Sigma = diag(4))
cf5 <- sample(c((-2):2), sample_size, replace = T)
cf6 <- runif(sample_size, min = -3, max = 3)
confounders = cbind(cf, cf5, cf6)
colnames(confounders) = c("cf1", "cf2", "cf3", "cf4", "cf5", "cf6")


cov_function <- function(confounders) as.vector(-0.8 + matrix(c(0.1, 0.1, -0.1, 0.2, 0.1, 0.1), nrow = 1) %*% t(confounders))

exposure = 9 * cov_function(confounders) + 17 + rnorm(sample_size, mean = 0, sd =  5)

exposure = 15 *  cov_function(confounders) + 17 + rt(sample_size, df = 2)

exposure = 9 * cov_function(confounders) + 3/2* (confounders[, "cf3"])^2 + 15 + rnorm(sample_size, mean = 0, sd =  5)

exposure = 49 * exp(cov_function(confounders)) / (1 + exp(cov_function(confounders))) - 6 + rnorm(sample_size, mean = 0, sd = 5)

exposure = 42 * 1 / (1 + exp(cov_function(confounders))) - 18 + rnorm(sample_size, mean = 0, sd = 5)

# If gps specification is 6
# Why dont they include the absolute value here?? 
#exposure = 7 * log(abs(cov_function(confounders))) + 13 + rnorm(sample_size, mean = 0, sd = 4)


# Check to make sure the range lines up
quantile(exposure, 0.05)
quantile(exposure, 0.95)
hist(exposure)


# start.time <- Sys.time()
sim_results <-
  mclapply(1:50, mc.cores = 10, function(i) {
    metrics_from_data(exposure = exposure, confounders = confounders, relationship = "linear", sample_size = sample_size, family = "poisson")
  })


# now extract metric results and sim results
metrics_results <- 
  rbindlist(lapply(sim_results, function(sim){
    return(sim[[1]])
}))

pred_results <- 
  rbindlist(lapply(sim_results, function(sim){
    return(sim[[2]])
}))

pred_results <- melt(pred_results, id = 1, variable.name = "model", value.name = "prediction")
pred_results <- 
  pred_results[, .(mean = mean(prediction),
                 lower = quantile(prediction, 0.025),
                 upper = quantile(prediction, 0.975)), by = .(model, exposure)]

# Now calculate coverage as whether CI covers the truth and average over all exposure values
coverage_data <- 
  merge(pred_results[model %in% c("linear_model", "gam_model", "eschif"), .(model, exposure, lower, upper)], 
      pred_results[model == "true_fit", .(exposure, mean)])

coverage_data <- coverage_data[, .(cov = between(mean, lower, upper)), by = .(exposure, model)][, .(coverage = 100*mean(cov)), by = .(model)]

final_fig <- 
  pred_results %>% 
  ggplot(aes(x = exposure, y = mean, ymin = lower, ymax = upper, color = model, fill = model, linetype = model)) + 
  geom_line() + 
  geom_ribbon(alpha = 0.2) + 
  theme_classic() + 
  labs(x = "Exposure", y = "HR")

print(final_fig)

# Aggregate over simulations to get estimate of bias (with standard error) and MSE (with standard error)
# final_results <- merge(metrics_results[, .(bias = mean(bias), mse = mean(mse)), by = .(model)], coverage_data)
# final_results <- metrics_results[, .(bias = mean(bias), mse = mean(mse)), by = .(model)]
#  
# knitr::kable(final_results)

print(final_fig)
```


different relationships: linear, 
Three different methods: unadjusted, linear, gam, different GPS methods
metrics like RMSE and bias from a descriptive standpoint they don't tell you about the fit and how it looks. Cool to have a plot of a bunch of different fits: columns are three different exposure effects, rows are different methods to fit it, true efect and then overlay 20 estimates from the simulation. Show how well the simulation estimates relate to the true across a simulation of the sample replicates. Visualize what is happening also behond the RMSE and bias values. Later on it would be a useful plot to have. Overlay the mean the replicates to little information, unbiased in the long run the mean will look similar. If you took 10 or 20 of the simulation replicates and put them randomly, so its not quite linear but there are different fits around linear. For linear you might see lines are not exact but close. Useful to see what the models are doing in trying to fit the exposure respone function. On top of that have a table of RMSE bias and coverage for these different settings.


A couple of other metrics in there as well, the plots would be a nice supplement to the table b

Cases where GAM creates a weird biased estimate because it is strange curve, a lot of uncertainty near the extremes because there are not a lot of data near. 

Be it the Bayesian causal response function, Implement to the continuous will help you make sure you are doing it right. The Bayesian one you can't transfer over right now without recreating a continuous outcome. 


Even if you are generating from a linear outcome but nonlinear confounder but in the outcome model it is linear, I would guess that if you reverse the siuation where you assume linearlity between exposure and confounder but nonlinearity in the outcome model, the amount of bias from linear model would be higher 

Misspecification of the outcome model will have larger consequences that confounding in the exposure model. Something interesting to look at, if you revert the situation and see which outcome is in the outcome vs exposure. 

MIspecify which one and how will the consequences be for the exposure model. The quesiton is whether you need to be less in assymptopia for the outcome model vs the expsoure. Very interesting theoretical result to look at. You learn 

Throw any fancer estimator that you want and you won't see big differences. However if you revert the situation and see nonlinearity in the outcome and linear in the outcome model. some methods will look better than others and eventually the double robust will work the best. 

change to predict at the same points from 0 to 15 for this paper 

